<div
    style="display: flex; justify-content: space-between; align-items: center; margin-top: 2rem; margin-bottom: 0.8rem;">
    <h4 id="section-analysis" style="margin: 0; font-weight: 700; color: var(--color-text);">ğŸ“Š ìƒì„¸ ë¶„ì„ ê²°ê³¼</h4>
    <div>
        <button type="button" class="outline contrast"
            onclick="downloadTableAsCsv('analysis-table', 'analysis_result.csv')"
            style="padding: 6px 16px; font-size: 0.85rem; margin-bottom: 0; margin-right: 0.5rem;">
            ğŸ’¾ CSVë¡œ ë‹¤ìš´ë¡œë“œ
        </button>
        <button type="button" class="outline contrast" onclick="copyTableText('analysis-table')"
            style="padding: 6px 16px; font-size: 0.85rem; margin-bottom: 0;">
            ğŸ“‹ í…ìŠ¤íŠ¸ë¡œ ë³µì‚¬
        </button>
    </div>
</div>

<div class="table-container">
    <table id="analysis-table" class="striped">
        <thead>
            <tr>
                <th scope="col" style="width: 12%;">íŒŒì¼ëª…</th>
                <th scope="col" style="width: 15%;">í‘œì œì–´</th>
                <th scope="col" style="width: 20%;">í’ˆì‚¬</th>
                <th scope="col" style="width: 10%;">ë“±ê¸‰</th>
                <th scope="col" style="width: 40px;">
                    <!-- Select All Checkbox (Optional, usually for merge we select manually) -->
                    <input type="checkbox" id="select-all-rows" onclick="toggleSelectAll(this)" style="display:none;">
                    ì„ íƒ
                </th>
                <th scope="col" style="width: 60px;">ë²ˆí˜¸</th>
                <th scope="col">ì–´ì ˆ (ì›ë¬¸)</th>
                <th scope="col" style="width: 60px; text-align: center;">ìˆ˜ì •</th>
            </tr>
        </thead>
        <tbody>
            {% for row in analysis_result %}
            <tr id="{{ row._ui_id }}" data-original-form="{{ row.form }}" data-tag-code="{{ row.tag_code }}"
                data-offset="{{ row.offset_start }}" data-ui-id="{{ row._ui_id }}" data-filename="{{ row.filename }}">
                <td class="cell-filename"
                    style="color: var(--color-primary); font-size: 0.9rem; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 120px;"
                    title="{{ row.filename }}">
                    {{ row.filename|default('-') }}
                </td>
                <td class="cell-form" style="font-weight: bold; color: var(--color-text);">{{ row.form }}</td>
                <td class="cell-pos">
                    <span data-tooltip="{{ row.tag_code }}" style="border-bottom: 1px dotted #888; cursor: help;">
                        {{ row.tag_name }}
                    </span>
                </td>
                <td class="cell-grade">
                    {% if 'ê¸‰' in row.level %}
                    <span class="grade-badge grade-{{ row.level[0] }}" style="font-size: 1rem; padding: 4px 12px;">
                        {{ row.level }}
                    </span>
                    {% else %}
                    <span style="color: var(--color-text-muted);">-</span>
                    {% endif %}
                </td>
                <td style="text-align: center;">
                    <input type="checkbox" class="row-selector" onchange="handleRowSelection()">
                </td>
                <td class="cell-id text-muted" style="text-align: center;">{{ loop.index }}</td>
                <td class="cell-desc" style="color: var(--color-secondary);">
                    {{ row.desc }}
                </td>
                <td style="text-align: center;">
                    <button class="btn-edit-row" onclick="openEditModal(this)" title="ë“±ê¸‰ ìˆ˜ë™ ìˆ˜ì •">
                        âœï¸
                    </button>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- ìˆ˜ë™ ìˆ˜ì • ëª¨ë‹¬ -->
<dialog id="word-edit-modal">
    <article style="min-width: 500px;">
        <header>
            <button aria-label="Close" rel="prev" onclick="closeEditModal()"></button>
            <strong>ğŸ› ï¸ ë“±ê¸‰ ìˆ˜ë™ ìˆ˜ì •</strong>
        </header>
        <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--color-text-muted);">
            ê²€ìƒ‰ì„ í†µí•´ í•´ë‹¹ í–‰ì˜ ì •ë³´ë¥¼ êµì²´í•©ë‹ˆë‹¤. <br>
            (ê¸°ì¡´ í‘œì œì–´ëŠ” ìœ ì§€ë˜ê±°ë‚˜ 'ê¸°ì¡´ -> ìƒˆë‹¨ì–´'ë¡œ í‘œì‹œë©ë‹ˆë‹¤.)
        </p>

        <!-- [MODIFIED] Unified Search Bar Style -->
        <div class="grid" style="grid-template-columns: 1fr 3fr; gap: 10px; margin-bottom: 1rem;">
            <select id="edit-search-type" style="margin-bottom:0;">
                <option value="word" selected>ë‹¨ì–´</option>
                <option value="grammar">ë¬¸ë²•</option>
            </select>
            <input type="search" id="edit-search-input" placeholder="ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ì¡ë‹¤, ì§„í™)" style="margin-bottom:0;"
                autocomplete="off">
        </div>

        <div id="edit-search-results"
            style="max-height: 300px; overflow-y: auto; border: 1px solid var(--muted-border-color); border-radius: 8px; display: none;">
            <!-- ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ -->
        </div>
    </article>
</dialog>

<!-- [NEW] Floating Merge Button -->
<div id="floating-merge-btn" style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); 
    background-color: var(--color-primary); color: white; padding: 12px 24px; border-radius: 30px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1000; display: none; cursor: pointer; font-weight: bold;
    transition: all 0.3s ease;">
    <span id="merge-count-badge" style="background: white; color: var(--color-primary); border-radius: 50%; 
        padding: 2px 8px; margin-right: 8px; font-size: 0.9em;">0</span>
    ì„ íƒí•œ ë‹¨ì–´ í•©ì¹˜ê¸°
</div>

<!-- [NEW] Merge Modal -->
<dialog id="merge-modal">
    <article style="min-width: 400px;">
        <header>
            <button aria-label="Close" rel="prev" onclick="closeMergeModal()"></button>
            <h3>ë‹¨ì–´ í•©ì¹˜ê¸°</h3>
        </header>
        <p>ì„ íƒí•œ ë‹¨ì–´ë“¤ì„ í•˜ë‚˜ë¡œ í•©ì¹©ë‹ˆë‹¤.</p>

        <label for="merge-input-text">í•©ì³ì§„ ë‹¨ì–´ (ìˆ˜ì • ê°€ëŠ¥)</label>
        <input type="text" id="merge-input-text">

        <label for="merge-input-grade">ìƒˆë¡œìš´ ë“±ê¸‰</label>
        <select id="merge-input-grade">
            <option value="1ê¸‰">1ê¸‰ (ì´ˆê¸‰)</option>
            <option value="2ê¸‰">2ê¸‰ (ì´ˆê¸‰)</option>
            <option value="3ê¸‰">3ê¸‰ (ì¤‘ê¸‰)</option>
            <option value="4ê¸‰">4ê¸‰ (ì¤‘ê¸‰)</option>
            <option value="5ê¸‰">5ê¸‰ (ê³ ê¸‰)</option>
            <option value="6ê¸‰">6ê¸‰ (ê³ ê¸‰)</option>
            <option value="ë“±ê¸‰ ì—†ìŒ">ë“±ê¸‰ ì—†ìŒ</option>
        </select>

        <footer>
            <button class="secondary" onclick="closeMergeModal()">ì·¨ì†Œ</button>
            <button onclick="applyMerge()">í™•ì¸</button>
        </footer>
    </article>
</dialog>

<style>
    .table-container {
        overflow-x: auto;
        border: 1px solid var(--muted-border-color);
        border-radius: 8px;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.05rem;
    }

    th {
        background-color: rgba(255, 255, 255, 0.05);
        text-align: left;
        font-weight: 600;
        padding: 14px;
    }

    td {
        padding: 14px;
        border-bottom: 1px solid var(--muted-border-color);
        vertical-align: middle;
    }

    tr:last-child td {
        border-bottom: none;
    }

    /* ì˜¤ë¦¬ì§€ë„ ë“±ê¸‰ ìƒ‰ìƒ ë³µì› (í…Œì´ë¸” ë‚´ë¶€ìš©) */
    .grade-badge {
        display: inline-block;
        border-radius: 12px;
        color: #fff;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .grade-1 {
        background-color: #10b981;
    }

    .grade-2 {
        background-color: #3b82f6;
    }

    .grade-3 {
        background-color: #8b5cf6;
    }

    .grade-4 {
        background-color: #f59e0b;
    }

    .grade-5 {
        background-color: #ef4444;
    }

    .grade-6 {
        background-color: #64748b;
    }


    /* ìˆ˜ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .btn-edit-row {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
        opacity: 0.3;
        transition: opacity 0.2s;
        padding: 4px;
    }

    .btn-edit-row:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    /* [MODIFIED] ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ ìŠ¤íƒ€ì¼ (Feature 2 í‘œì¤€ê³¼ ë™ì¼í•˜ê²Œ ìˆ˜ì •) */
    .edit-result-item {
        padding: 12px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.1s;
        text-align: left;
        /* ê¸°ì¡´ flex/background ì œê±°í•˜ì—¬ Feature 2 ìŠ¤íƒ€ì¼ë¡œ í†µì¼ */
    }

    .edit-result-item:hover {
        background-color: #3e3e3e;
    }

    .edit-result-item:last-child {
        border-bottom: none;
    }

    /* [NEW] Row Highlight System using Transitions (Final Fix) */

    /* 1. Base State (Hidden/Transparent) */
    /* We don't need a specific base state class, default is none */

    /* 2. Start State: Immediate Appearance */
    /* Common: Top & Bottom Borders + Background */
    tr.highlight-start td {
        background-color: rgba(0, 180, 216, 0.2) !important;
        box-shadow: inset 0 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
        transition: none !important;
        /* Force instant apply */
    }

    /* Left Border for First Cell */
    tr.highlight-start td:first-child {
        box-shadow: inset 2px 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
    }

    /* Right Border for Last Cell */
    tr.highlight-start td:last-child {
        box-shadow: inset -2px 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
    }

    /* 3. Fade State: Smooth Transition to Transparent (1s Fade) */
    tr.highlight-start.highlight-fade td {
        background-color: transparent !important;
        box-shadow: inset 0 2px 0 transparent, inset 0 -2px 0 transparent !important;
        transition: background-color 1s ease-out, box-shadow 1s ease-out !important;
    }

    tr.highlight-start.highlight-fade td:first-child {
        box-shadow: inset 2px 2px 0 transparent, inset 0 -2px 0 transparent !important;
    }

    tr.highlight-start.highlight-fade td:last-child {
        box-shadow: inset -2px 2px 0 transparent, inset 0 -2px 0 transparent !important;
    }
</style>

<script>
    let currentEditingRow = null;
    let localDebounceTimer; // [NEW] ë””ë°”ìš´ì‹± íƒ€ì´ë¨¸

    function openEditModal(btn) {
        currentEditingRow = btn.closest('tr');
        const modal = document.getElementById('word-edit-modal');
        modal.showModal();

        // [NEW] Auto-Search Implementation
        const originalForm = currentEditingRow.dataset.originalForm || currentEditingRow.querySelector('.cell-form').innerText;
        const tagCode = currentEditingRow.dataset.tagCode || ""; // Get tag code

        const searchInput = document.getElementById('edit-search-input');
        const typeSelect = document.getElementById('edit-search-type');

        // Auto-detect type
        if (tagCode.startsWith('J') || tagCode.startsWith('E')) {
            typeSelect.value = 'grammar';
        } else {
            typeSelect.value = 'word';
        }

        searchInput.value = originalForm; // Pre-fill
        searchInput.focus();

        // Trigger search immediately with correct type
        searchForEdit(originalForm, typeSelect.value);
    }

    function closeEditModal() {
        const modal = document.getElementById('word-edit-modal');
        modal.close();
        currentEditingRow = null;
    }

    // [MODIFIED] ë””ë°”ìš´ì‹± ì ìš©ëœ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const editSearchInput = document.getElementById('edit-search-input');
    if (editSearchInput) {
        // ì—”í„°í‚¤ ë°©ì§€ (í¼ ì „ì†¡ ë°©ì§€)
        editSearchInput.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') e.preventDefault();
        });

        editSearchInput.addEventListener('input', function () {
            const query = this.value.trim();
            const type = document.getElementById('edit-search-type').value;

            if (query.length < 1) {
                clearTimeout(localDebounceTimer);
                document.getElementById('edit-search-results').style.display = 'none';
                return;
            }

            // ë””ë°”ìš´ì‹± (300ms)
            clearTimeout(localDebounceTimer);
            localDebounceTimer = setTimeout(() => {
                searchForEdit(query, type);
            }, 300);
        });
    }

    async function searchForEdit(query, type) {
        const list = document.getElementById('edit-search-results');
        // list.innerHTML = '<div style="padding:10px; text-align:center;">ê²€ìƒ‰ ì¤‘...</div>'; 
        // -> ê²€ìƒ‰ ì¤‘ í‘œì‹œëŠ” íƒ€ì´í•‘ ì¤‘ì— ê±°ìŠ¬ë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìƒëµí•˜ê±°ë‚˜ ìµœì†Œí™”

        try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}&type=${type}`);
            const data = await res.json();

            list.innerHTML = '';
            if (data.length === 0) {
                list.style.display = 'block';
                list.innerHTML = '<div style="padding:10px; text-align:center; color:#888;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            list.style.display = 'block';
            data.forEach(item => {
                const div = document.createElement('div');
                div.className = 'edit-result-item'; // CSS í´ë˜ìŠ¤ ì ìš©

                // ë Œë”ë§ ë¡œì§ (search.jsì™€ ë™ì¼í•˜ê²Œ êµ¬ì„±)

                // 1. íŒíŠ¸
                const hintText = (item.desc && item.desc !== 'nan')
                    ? `<span style="color:#aaa; font-size:0.85em; margin-left:6px;">${item.desc}</span>`
                    : '';

                // 2. í’ˆì‚¬
                const posText = item.pos
                    ? `<span style="color:#a855f7; font-weight:600; font-size:0.85em; margin-left:4px;">[${item.pos}]</span>`
                    : '';

                // 3. ê´€ë ¨í˜•
                let relatedText = '';
                if (item.related) {
                    relatedText = `<span style="color:#ff9f43; font-size:0.8em; margin-left:6px;">(ê´€ë ¨í˜•: ${item.related})</span>`;
                }

                // 4. ë“±ê¸‰ ë°°ì§€ (Solid Color)
                const gradeNum = item.grade.replace(/[^0-9]/g, '');
                const colorMap = {
                    '1': '#10b981', '2': '#3b82f6', '3': '#8b5cf6',
                    '4': '#f59e0b', '5': '#ef4444', '6': '#64748b'
                };
                const bgColor = colorMap[gradeNum] || '#94a3b8';

                div.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            <strong>${item.text}</strong>
                            ${posText}
                            ${relatedText}
                            ${hintText}
                        </div>
                        <span style="font-size:0.75em; color:#fff; background:${bgColor}; padding: 2px 6px; border-radius:4px; white-space: nowrap; margin-left: 10px;">
                            ${item.grade}
                        </span>
                    </div>
                `;

                div.onclick = () => applyEdit(item);
                list.appendChild(div);
            });

        } catch (e) {
            list.innerHTML = `<div style="padding:10px; color:red;">ì—ëŸ¬: ${e}</div>`;
        }
    }

    function applyEdit(item) {
        if (!currentEditingRow) return;

        // [NEW] Text Cleaning Logic
        // 1. Remove trailing numbers (e.g., "ì‹ ë¬¸02" -> "ì‹ ë¬¸")
        // 2. Remove leading/trailing hyphens/tildes (e.g., "-ì„ê¹Œ" -> "ì„ê¹Œ")
        let cleanText = item.text || item.word || "";
        cleanText = cleanText.replace(/[0-9]+$/, '');
        cleanText = cleanText.replace(/^[-~]+|[-~]+$/g, '');

        // 1. í‘œì œì–´ (ì›ë˜ -> ìƒˆê±°)
        const originalForm = currentEditingRow.dataset.originalForm || currentEditingRow.querySelector('.cell-form').innerText;
        // ë§Œì•½ ì´ë¯¸ ìˆ˜ì •ëœ ìƒíƒœë¼ë©´ originalForm ìœ ì§€
        if (!currentEditingRow.dataset.originalForm) {
            currentEditingRow.dataset.originalForm = originalForm;
        }

        const formCell = currentEditingRow.querySelector('.cell-form');
        // ê°™ì€ ë‹¨ì–´ë©´ ê·¸ëŒ€ë¡œ, ë‹¤ë¥´ë©´ í™”ì‚´í‘œ í‘œì‹œ
        if (originalForm === cleanText) {
            formCell.innerText = cleanText;
        } else {
            formCell.innerHTML = `<span style="text-decoration: line-through; color: #999; font-weight:normal;">${originalForm}</span> âœ ${cleanText}`;
        }

        // 2. í’ˆì‚¬
        const posCell = currentEditingRow.querySelector('.cell-pos');
        posCell.innerHTML = `<span>${item.pos}</span> <span style="font-size:0.7em; color:violet;">(ìˆ˜ì •ë¨)</span>`;

        // 3. ë“±ê¸‰ (Keep original solid badges in the table, user only asked for SEARCH results to be changed)
        const gradeCell = currentEditingRow.querySelector('.cell-grade');
        const gradeNum = item.grade.replace('ê¸‰', '');
        gradeCell.innerHTML = `<span class="grade-badge grade-${gradeNum}" style="font-size: 1rem; padding: 4px 12px;">${item.grade}</span>`;

        // 4. ë²ˆí˜¸ (ID)
        const idCell = currentEditingRow.querySelector('.cell-id');
        idCell.innerText = "ìˆ˜ë™êµì •";

        // 5. ê¸¸ì¡ì´ë§
        const descCell = currentEditingRow.querySelector('.cell-desc');
        descCell.innerText = item.desc || item.meaning;

        // [NEW] Refresh Full UI (Pie Chart + Overall Grade + Visualized Text)
        if (window.refreshGradeChart) {
            window.refreshGradeChart(); // Internally calls updateOverallGrade
        }

        if (window.updateVisualizedText) {
            const offset = currentEditingRow.dataset.offset;
            const uiId = currentEditingRow.dataset.uiId;
            // Use cleaned text for visualization as well
            const newText = cleanText;

            // Robustly get original form (try dataset first, then cell text)
            let originalForm = currentEditingRow.dataset.originalForm;
            if (!originalForm) {
                const formCell = currentEditingRow.querySelector('.cell-form');
                if (formCell) originalForm = formCell.innerText.trim();
            }

            window.updateVisualizedText(offset, item.grade, item.desc || item.meaning, newText, originalForm || "", uiId);
        }

        // [Moved] Close modal LAST to ensure currentEditingRow remains valid during updates
        closeEditModal();
    }

    // [NEW] Selection & Merge Logic
    let selectedRows = [];

    function handleRowSelection() {
        // Find all selected checkboxes
        const checkboxes = document.querySelectorAll('.row-selector:checked');
        selectedRows = Array.from(checkboxes).map(cb => cb.closest('tr'));

        const btn = document.getElementById('floating-merge-btn');
        const countBadge = document.getElementById('merge-count-badge');

        if (selectedRows.length >= 2) {
            // Check adjacency (Optional but recommended)
            // Implementation: Sort by rowIndex and check gaps? 
            // For now, allow any selection but visually implies adjacency.
            // User likely selects contiguous.

            btn.style.display = 'block';
            countBadge.innerText = selectedRows.length;

            // Add click listener
            btn.onclick = openMergeModal;
        } else {
            btn.style.display = 'none';
        }
    }

    function openMergeModal() {
        if (selectedRows.length < 2) return;

        // Sort selected rows by DOM order to ensure correct concatenation
        selectedRows.sort((a, b) => a.rowIndex - b.rowIndex);

        // Pre-fill merged text
        const combinedText = selectedRows.map(row => {
            const formCell = row.querySelector('.cell-form');
            // If already edited, use text only?
            // Use dataset.originalForm if available? No, we want CURRENT text.
            return formCell.innerText.trim();
        }).join('');

        const modal = document.getElementById('merge-modal');
        const input = document.getElementById('merge-input-text');
        input.value = combinedText;

        // Default grade? Maybe max of selected? Or unclassified.
        document.getElementById('merge-input-grade').value = 'ë“±ê¸‰ ì—†ìŒ';

        modal.showModal();
    }

    function closeMergeModal() {
        document.getElementById('merge-modal').close();
    }

    function applyMerge() {
        const modal = document.getElementById('merge-modal');
        const newText = document.getElementById('merge-input-text').value.trim();
        const newGrade = document.getElementById('merge-input-grade').value;
        const newDesc = "í•©ì³ì§„ ë‹¨ì–´"; // Simple desc

        if (!newText) {
            alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        // 1. Update First Row
        const firstRow = selectedRows[0];
        const formCell = firstRow.querySelector('.cell-form');
        const gradeCell = firstRow.querySelector('.cell-grade');
        const posCell = firstRow.querySelector('.cell-pos');
        const descCell = firstRow.querySelector('.cell-desc');
        const idCell = firstRow.querySelector('.cell-id');

        // Update Content
        formCell.innerText = newText;

        // Grade Badge
        const gradeNum = newGrade.replace(/[^0-9]/g, '');
        const badgeColorClass = gradeNum ? `grade-${gradeNum}` : 'grade-none';
        const badgeStyle = gradeNum ? '' : 'background-color:#94a3b8; color:white;'; // Custom style for 'ë“±ê¸‰ ì—†ìŒ' if class missing

        gradeCell.innerHTML = `<span class="grade-badge ${badgeColorClass}" style="font-size: 1rem; padding: 4px 12px; ${badgeStyle}">${newGrade}</span>`;

        posCell.innerHTML = `<span style="font-size:0.8em; color:violet;">(ë³‘í•©ë¨)</span>`;
        descCell.innerText = newDesc;
        idCell.innerText = "ìˆ˜ë™ë³‘í•©";

        // 2. Remove Other Rows
        for (let i = 1; i < selectedRows.length; i++) {
            selectedRows[i].remove();
        }

        // 3. Call Visualization Update
        // Provide list of UI IDs to merge
        if (window.mergeVisualizedText) {
            const uiIds = selectedRows.map(row => row.dataset.uiId);
            window.mergeVisualizedText(uiIds, newText, newGrade, newDesc);
        }

        // 4. Update Charts
        if (window.refreshGradeChart) {
            window.refreshGradeChart();
        }

        // 5. Cleanup
        modal.close();

        // Reset Selection
        document.querySelectorAll('.row-selector').forEach(cb => cb.checked = false);
        handleRowSelection(); // Hide button
    }
</script>