<div
    style="display: flex; justify-content: space-between; align-items: center; margin-top: 2rem; margin-bottom: 0.8rem;">
    <h4 id="section-analysis" style="margin: 0; font-weight: 700; color: var(--color-text);">ğŸ“Š ìƒì„¸ ë¶„ì„ ê²°ê³¼</h4>
    <div>
        <button type="button" class="outline contrast"
            onclick="downloadTableAsCsv('analysis-table', 'analysis_result.csv')"
            style="padding: 6px 16px; font-size: 0.85rem; margin-bottom: 0; margin-right: 0.5rem;">
            ğŸ’¾ CSVë¡œ ë‹¤ìš´ë¡œë“œ
        </button>
        <button type="button" class="outline contrast" onclick="copyTableText('analysis-table')"
            style="padding: 6px 16px; font-size: 0.85rem; margin-bottom: 0;">
            ğŸ“‹ í…ìŠ¤íŠ¸ë¡œ ë³µì‚¬
        </button>
    </div>
</div>

<div class="table-container">
    <table id="analysis-table" class="striped">
        <thead>
            <tr>
                <th scope="col" style="width: 12%;">íŒŒì¼ëª…</th>
                <th scope="col" style="width: 15%;">í‘œì œì–´</th>
                <th scope="col" style="width: 20%;">í’ˆì‚¬</th>
                <th scope="col" style="width: 10%;">ë“±ê¸‰</th>
                <th scope="col" style="width: 12%;">ë²ˆí˜¸</th>
                <th scope="col">ê¸¸ì¡ì´ë§</th>
                <th scope="col" style="width: 80px; text-align: center;">ìˆ˜ì •</th> <!-- ìˆ˜ì •/ì„ íƒ ì²´í¬ë°•ìŠ¤ -->
            </tr>
        </thead>
        <tbody>
            {% for row in analysis_result %}
            <tr id="{{ row._ui_id }}" data-original-form="{{ row.form }}" data-tag-code="{{ row.tag_code }}"
                data-offset="{{ row.offset_start }}" data-ui-id="{{ row._ui_id }}" data-filename="{{ row.filename }}">
                <td class="cell-filename"
                    style="color: var(--color-primary); font-size: 0.9rem; font-weight: bold; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 120px;"
                    title="{{ row.filename }}">
                    {{ row.filename|default('-') }}
                </td>
                <td class="cell-form" style="font-weight: bold; color: var(--color-text);">{{ row.form }}</td>
                <td class="cell-pos">
                    <span class="pos-tooltip-target" data-tooltip="{{ row.tag_code }}"
                        style="border-bottom: 1px dotted #888; cursor: help;">
                        {{ row.tag_name }}
                    </span>
                </td>
                <td class="cell-grade">
                    {% if 'ê¸‰' in row.level %}
                    <span class="grade-badge grade-{{ row.level[0] }}" style="font-size: 1rem; padding: 4px 12px;">
                        {{ row.level }}
                    </span>
                    {% else %}
                    <span style="color: var(--color-text-muted);">-</span>
                    {% endif %}
                </td>
                <td class="cell-id" style="font-size: 0.85rem; color: var(--color-text-muted);">
                    {{ row.id }}
                </td>
                <td class="cell-desc" style="color: var(--color-secondary);">
                    {{ row.desc }}
                </td>
                <td style="text-align: center;">
                    <!-- í–‰ ì„ íƒ ì²´í¬ë°•ìŠ¤ (ë³‘í•© ë° ì¼ê´„ ìˆ˜ì •ìš©) -->
                    <input type="checkbox" class="row-selector" onchange="handleRowSelection()">
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- ìˆ˜ë™ ìˆ˜ì • ëª¨ë‹¬ -->
<dialog id="word-edit-modal">
    <article style="min-width: 500px;">
        <header>
            <button aria-label="Close" rel="prev" onclick="closeEditModal()"></button>
            <strong>ğŸ› ï¸ ë“±ê¸‰ ìˆ˜ë™ ìˆ˜ì •</strong>
        </header>
        <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--color-text-muted);">
            ê²€ìƒ‰ì„ í†µí•´ í•´ë‹¹ í–‰ì˜ ì •ë³´ë¥¼ êµì²´í•©ë‹ˆë‹¤. <br>
            (ê¸°ì¡´ í‘œì œì–´ëŠ” ìœ ì§€ë˜ê±°ë‚˜ 'ê¸°ì¡´ -> ìƒˆë‹¨ì–´'ë¡œ í‘œì‹œë©ë‹ˆë‹¤.)
        </p>

        <!-- ê²€ìƒ‰ì°½ (ë‹¨ì–´/ë¬¸ë²• ì„ íƒ ê°€ëŠ¥) -->
        <div class="grid" style="grid-template-columns: 1fr 3fr; gap: 10px; margin-bottom: 1rem;">
            <select id="edit-search-type" style="margin-bottom:0;">
                <option value="word" selected>ë‹¨ì–´</option>
                <option value="grammar">ë¬¸ë²•</option>
            </select>
            <input type="search" id="edit-search-input" placeholder="ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ì¡ë‹¤, ì§„í™)" style="margin-bottom:0;"
                autocomplete="off">
        </div>

        <div id="edit-search-results"
            style="max-height: 300px; overflow-y: auto; border: 1px solid var(--muted-border-color); border-radius: 8px; display: none;">
            <!-- ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ -->
        </div>
    </article>
</dialog>

<!-- ë³‘í•© ë²„íŠ¼ (í”Œë¡œíŒ…) -->
<div id="floating-merge-btn" style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); 
    background-color: var(--color-primary); color: white; padding: 12px 24px; border-radius: 30px; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 1000; display: none; cursor: pointer; font-weight: bold;
    transition: all 0.3s ease;">
    <span id="merge-count-badge" style="background: white; color: var(--color-primary); border-radius: 50%; 
        padding: 2px 8px; margin-right: 8px; font-size: 0.9em;">0</span>
    ì„ íƒí•œ ë‹¨ì–´ ìˆ˜ì •í•˜ê¸°
</div>

<!-- ë³‘í•© ì„¤ì • ëª¨ë‹¬ -->
<dialog id="merge-modal">
    <article style="min-width: 400px;">
        <header>
            <button aria-label="Close" rel="prev" onclick="closeMergeModal()"></button>
            <h3>ë‹¨ì–´ í•©ì¹˜ê¸°</h3>
        </header>
        <p>ì„ íƒí•œ ë‹¨ì–´ë“¤ì„ í•˜ë‚˜ë¡œ í•©ì¹©ë‹ˆë‹¤.</p>

        <label for="merge-input-text">í•©ì³ì§„ ë‹¨ì–´ (ìˆ˜ì • ê°€ëŠ¥)</label>
        <input type="text" id="merge-input-text">

        <label for="merge-input-grade">ìƒˆë¡œìš´ ë“±ê¸‰</label>
        <select id="merge-input-grade">
            <option value="1ê¸‰">1ê¸‰ (ì´ˆê¸‰)</option>
            <option value="2ê¸‰">2ê¸‰ (ì´ˆê¸‰)</option>
            <option value="3ê¸‰">3ê¸‰ (ì¤‘ê¸‰)</option>
            <option value="4ê¸‰">4ê¸‰ (ì¤‘ê¸‰)</option>
            <option value="5ê¸‰">5ê¸‰ (ê³ ê¸‰)</option>
            <option value="6ê¸‰">6ê¸‰ (ê³ ê¸‰)</option>
            <option value="ë“±ê¸‰ ì—†ìŒ">ë“±ê¸‰ ì—†ìŒ</option>
        </select>

        <footer>
            <button class="secondary" onclick="closeMergeModal()">ì·¨ì†Œ</button>
            <button onclick="applyMerge()">í™•ì¸</button>
        </footer>
    </article>
</dialog>

<!-- ì„ íƒí•œ í•­ëª© ì¼ê´„ ìˆ˜ì • ëª¨ë‹¬ -->
<dialog id="selection-edit-modal">
    <article style="width: 100%; max-width: 1100px; min-width: 500px; padding: 1.5rem;">
        <header style="padding-bottom: 0.5rem;">
            <button aria-label="Close" rel="prev" onclick="closeSelectionEditModal()"></button>
            <h3 style="font-size: 1.1rem; margin: 0;">ì„ íƒí•œ ë‹¨ì–´ ìˆ˜ì •í•˜ê¸°</h3>
        </header>

        <div style="max-height: 60vh; overflow-y: auto; margin: 0.5rem 0;">
            <table class="striped" id="selection-edit-table"
                style="width: 100%; border-collapse: collapse; font-size: 1.05rem;">
                <thead>
                    <tr>
                        <th style="padding: 8px 10px; font-size: 1rem;">íŒŒì¼ëª…</th>
                        <th style="padding: 8px 10px; font-size: 1rem;">í‘œì œì–´</th>
                        <th style="padding: 8px 10px; font-size: 1rem;">í’ˆì‚¬</th>
                        <th style="padding: 8px 10px; font-size: 1rem;">ë“±ê¸‰</th>
                        <th style="padding: 8px 10px; font-size: 1rem;">ë²ˆí˜¸</th>
                        <th style="padding: 8px 10px; font-size: 1rem;">ê¸¸ì¡ì´ë§</th>
                        <th style="padding: 8px 12px; text-align: center; min-width: 80px; font-size: 1rem;">ìˆ˜ì •</th>
                    </tr>
                </thead>
                <tbody id="selection-edit-tbody">
                    <!-- JS populate -->
                </tbody>
            </table>
        </div>

        <footer style="display: flex; gap: 10px; justify-content: flex-end; padding-top: 0.5rem;">
            <button class="secondary" onclick="closeSelectionEditModal()" style="padding: 0.4rem 1rem;">ì·¨ì†Œ</button>
            <button onclick="confirmSelectionEdits()" style="padding: 0.4rem 1rem;">í™•ì¸</button>
        </footer>
    </article>
</dialog>


<style>
    .table-container {
        overflow-x: auto;
        border: 1px solid var(--muted-border-color);
        border-radius: 8px;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.05rem;
    }

    th {
        background-color: rgba(255, 255, 255, 0.05);
        text-align: left;
        font-weight: 600;
        padding: 14px;
    }

    td {
        padding: 14px;
        border-bottom: 1px solid var(--muted-border-color);
        vertical-align: middle;
    }

    tr:last-child td {
        border-bottom: none;
    }

    /* ì˜¤ë¦¬ì§€ë„ ë“±ê¸‰ ìƒ‰ìƒ ë³µì› (í…Œì´ë¸” ë‚´ë¶€ìš©) */
    .grade-badge {
        display: inline-block;
        border-radius: 12px;
        color: #fff;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .grade-1 {
        background-color: #10b981;
    }

    .grade-2 {
        background-color: #3b82f6;
    }

    .grade-3 {
        background-color: #8b5cf6;
    }

    .grade-4 {
        background-color: #f59e0b;
    }

    .grade-5 {
        background-color: #ef4444;
    }

    .grade-6 {
        background-color: #64748b;
    }


    /* ìˆ˜ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .btn-edit-row {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
        opacity: 0.3;
        transition: opacity 0.2s;
        padding: 4px;
    }

    .btn-edit-row:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    /* [MODIFIED] ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ ìŠ¤íƒ€ì¼ (Feature 2 í‘œì¤€ê³¼ ë™ì¼í•˜ê²Œ ìˆ˜ì •) */
    .edit-result-item {
        padding: 12px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.1s;
        text-align: left;
        /* ê¸°ì¡´ flex/background ì œê±°í•˜ì—¬ Feature 2 ìŠ¤íƒ€ì¼ë¡œ í†µì¼ */
    }

    .edit-result-item:hover {
        background-color: #3e3e3e;
    }

    .edit-result-item:last-child {
        border-bottom: none;
    }

    /* [NEW] Merge Button Styles */
    .merge-btn {
        background: transparent !important;
        /* Force transparent */
        border: 1px solid var(--color-primary);
        color: var(--color-primary);
        border-radius: 50%;
        width: 28px;
        height: 28px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        padding: 0;
        opacity: 0.5;
    }

    .merge-btn:hover {
        opacity: 1;
        /* background: var(--color-primary); REMOVED background fill on hover */
        border-color: var(--color-primary);
        color: var(--color-primary);
        font-weight: bold;
        transform: scale(1.1);
        box-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.3);
        /* Subtle glow instead */
    }

    .merge-button-row {
        background: transparent !important;
    }

    .merge-button-row td {
        border: none !important;
        background: transparent !important;
    }


    /* í–‰ í•˜ì´ë¼ì´íŠ¸ ì‹œìŠ¤í…œ (Transition í™œìš©) */

    /* 1. ê¸°ë³¸ ìƒíƒœ (ìˆ¨ê¹€/íˆ¬ëª…) */
    /* We don't need a specific base state class, default is none */

    /* 2. Start State: Immediate Appearance */
    /* Common: Top & Bottom Borders + Background */
    tr.highlight-start td {
        background-color: rgba(0, 180, 216, 0.2) !important;
        box-shadow: inset 0 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
        transition: none !important;
        /* Force instant apply */
    }

    /* Left Border for First Cell */
    tr.highlight-start td:first-child {
        box-shadow: inset 2px 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
    }

    /* Right Border for Last Cell */
    tr.highlight-start td:last-child {
        box-shadow: inset -2px 2px 0 #00b4d8, inset 0 -2px 0 #00b4d8 !important;
    }

    /* 3. Fade State: Smooth Transition to Transparent (1s Fade) */
    tr.highlight-start.highlight-fade td {
        background-color: transparent !important;
        box-shadow: inset 0 2px 0 transparent, inset 0 -2px 0 transparent !important;
        transition: background-color 1s ease-out, box-shadow 1s ease-out !important;
    }

    tr.highlight-start.highlight-fade td:first-child {
        box-shadow: inset 2px 2px 0 transparent, inset 0 -2px 0 transparent !important;
    }

    tr.highlight-start.highlight-fade td:last-child {
        box-shadow: inset -2px 2px 0 transparent, inset 0 -2px 0 transparent !important;
    }

    /* ë¶„ì„ í…Œì´ë¸” íˆ´íŒ ìŠ¤íƒ€ì¼ (Visualizationê³¼ ìœ ì‚¬) */
    #pos-tooltip {
        position: fixed;
        background-color: var(--color-text);
        color: var(--background-color);
        padding: 0.5rem 0.8rem;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 600;
        white-space: nowrap;
        pointer-events: none;
        z-index: 2147483647;
        opacity: 0;
        transition: opacity 0.1s;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        transform: translate(-50%, -100%);
    }

    #pos-tooltip::after {
        content: '';
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -6px;
        border-width: 6px;
        border-style: solid;
        border-color: var(--color-text) transparent transparent transparent;
    }
</style>

<!-- ë¶„ì„ í…Œì´ë¸”ìš© íˆ´íŒ ìš”ì†Œ -->
<div id="pos-tooltip"></div>

<script>
    document.addEventListener('DOMContentLoaded', function () {
        // Shared logic with visualization, but independent element
        const tooltip = document.getElementById('pos-tooltip');
        // We attach listener to the table body to catch events bubbling up
        const tableBody = document.querySelector('#analysis-table tbody');

        if (tableBody && tooltip) {
            tableBody.addEventListener('mouseover', function (e) {
                const target = e.target.closest('.pos-tooltip-target');
                if (target && target.dataset.tooltip) {
                    tooltip.innerText = target.dataset.tooltip;

                    const rect = target.getBoundingClientRect();
                    tooltip.style.left = (rect.left + rect.width / 2) + 'px';
                    tooltip.style.top = (rect.top - 6) + 'px';

                    tooltip.style.opacity = '1';
                }
            });

            tableBody.addEventListener('mouseout', function (e) {
                const target = e.target.closest('.pos-tooltip-target');
                if (target) {
                    tooltip.style.opacity = '0';
                }
            });

            // Hide on scroll
            window.addEventListener('scroll', function () {
                tooltip.style.opacity = '0';
            }, { passive: true });
        }
    });
</script>

<script>
    let currentEditingRow = null;
    let localDebounceTimer; // [NEW] ë””ë°”ìš´ì‹± íƒ€ì´ë¨¸

    function openEditModal(btnOrRow, initialSearchText = null) {
        // [MODIFIED] Accept Button or Row Element
        if (btnOrRow.tagName === 'TR') {
            currentEditingRow = btnOrRow;
        } else {
            currentEditingRow = btnOrRow.closest('tr');
        }
        const modal = document.getElementById('word-edit-modal');
        modal.showModal();

        // ìë™ ê²€ìƒ‰ ê¸°ëŠ¥:
        // ì´ˆê¸° ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´ ì‚¬ìš©í•˜ê³ , ì—†ìœ¼ë©´ ì›ë³¸ í˜•íƒœë¥¼ ì‚¬ìš© (ë³‘í•©ëœ í˜•íƒœ ìš°ì„ )
        const originalForm = initialSearchText || currentEditingRow.dataset.originalForm || currentEditingRow.querySelector('.cell-form').innerText;
        const tagCode = currentEditingRow.dataset.tagCode || ""; // Get tag code

        const searchInput = document.getElementById('edit-search-input');
        const typeSelect = document.getElementById('edit-search-type');

        // Auto-detect type
        if (tagCode.startsWith('J') || tagCode.startsWith('E')) {
            typeSelect.value = 'grammar';
        } else {
            typeSelect.value = 'word';
        }

        searchInput.value = originalForm; // Pre-fill with correct form
        searchInput.focus();

        // Trigger search immediately with correct type
        searchForEdit(originalForm, typeSelect.value);
    }



    function closeEditModal() {
        const modal = document.getElementById('word-edit-modal');
        modal.close();
        currentEditingRow = null;
    }

    // [MODIFIED] ë””ë°”ìš´ì‹± ì ìš©ëœ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const editSearchInput = document.getElementById('edit-search-input');
    if (editSearchInput) {
        // ì—”í„°í‚¤ ë°©ì§€ (í¼ ì „ì†¡ ë°©ì§€)
        editSearchInput.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') e.preventDefault();
        });

        editSearchInput.addEventListener('input', function () {
            const query = this.value.trim();
            const type = document.getElementById('edit-search-type').value;

            if (query.length < 1) {
                clearTimeout(localDebounceTimer);
                document.getElementById('edit-search-results').style.display = 'none';
                return;
            }

            // ë””ë°”ìš´ì‹± (300ms)
            clearTimeout(localDebounceTimer);
            localDebounceTimer = setTimeout(() => {
                searchForEdit(query, type);
            }, 300);
        });
    }

    async function searchForEdit(query, type) {
        const list = document.getElementById('edit-search-results');
        // list.innerHTML = '<div style="padding:10px; text-align:center;">ê²€ìƒ‰ ì¤‘...</div>'; 
        // -> ê²€ìƒ‰ ì¤‘ í‘œì‹œëŠ” íƒ€ì´í•‘ ì¤‘ì— ê±°ìŠ¬ë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìƒëµí•˜ê±°ë‚˜ ìµœì†Œí™”

        try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}&type=${type}`);
            const data = await res.json();

            list.innerHTML = '';
            if (data.length === 0) {
                list.style.display = 'block';
                list.innerHTML = '<div style="padding:10px; text-align:center; color:#888;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            list.style.display = 'block';
            data.forEach(item => {
                const div = document.createElement('div');
                div.className = 'edit-result-item'; // CSS í´ë˜ìŠ¤ ì ìš©

                // ë Œë”ë§ ë¡œì§ (search.jsì™€ ë™ì¼í•˜ê²Œ êµ¬ì„±)

                // 1. íŒíŠ¸
                const hintText = (item.desc && item.desc !== 'nan')
                    ? `<span style="color:#aaa; font-size:0.85em; margin-left:6px;">${item.desc}</span>`
                    : '';

                // 2. í’ˆì‚¬
                const posText = item.pos
                    ? `<span style="color:#a855f7; font-weight:600; font-size:0.85em; margin-left:4px;">[${item.pos}]</span>`
                    : '';

                // 3. ê´€ë ¨í˜•
                let relatedText = '';
                if (item.related) {
                    relatedText = `<span style="color:#ff9f43; font-size:0.8em; margin-left:6px;">(ê´€ë ¨í˜•: ${item.related})</span>`;
                }

                // 4. ë“±ê¸‰ ë°°ì§€ (Solid Color)
                const gradeNum = item.grade.replace(/[^0-9]/g, '');
                const colorMap = {
                    '1': '#10b981', '2': '#3b82f6', '3': '#8b5cf6',
                    '4': '#f59e0b', '5': '#ef4444', '6': '#64748b'
                };
                const bgColor = colorMap[gradeNum] || '#94a3b8';

                div.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                <strong>${item.text}</strong>
                ${posText}
                ${relatedText}
                ${hintText}
            </div>
            <span style="font-size:0.75em; color:#fff; background:${bgColor}; padding: 2px 6px; border-radius:4px; white-space: nowrap; margin-left: 10px;">
                ${item.grade}
            </span>
        </div>
        `;

                // [NEW] Inject type for ID formatting
                item.type = type;
                div.onclick = () => applyEdit(item);
                list.appendChild(div);
            });

        } catch (e) {
            list.innerHTML = `<div style="padding:10px; color:red;">ì—ëŸ¬: ${e}</div>`;
        }
    }

    function applyEdit(item) {
        if (!currentEditingRow) return;

        // í…ìŠ¤íŠ¸ ì •ì œ ë¡œì§ (ìˆ«ì, ë¬¸ì¥ë¶€í˜¸ ì œê±°)
        let cleanText = item.text || item.word || "";
        cleanText = cleanText.replace(/[0-9]+$/, '');
        cleanText = cleanText.replace(/^[-~]+|[-~]+$/g, '');

        // 1. Check Context: Main Table or Selection Modal?
        const isInsideModal = currentEditingRow.closest('#selection-edit-modal');

        // Common Logic: HTML for Cells
        // Form
        // If merged row in modal, we shouldn't show arrow. Just new text.
        // Wait, currentEditingRow in modal *is* the one we want to update.
        const originalForm = currentEditingRow.dataset.originalForm || currentEditingRow.querySelector(isInsideModal ? '.modal-cell-form' : '.cell-form').innerText.trim();

        let formHtml = '';
        if (isInsideModal && currentEditingRow.dataset.merged === 'true') {
            formHtml = cleanText; // Merged rows just show new text
        } else {
            if (originalForm === cleanText) {
                formHtml = cleanText;
            } else {
                formHtml = `<span style="text-decoration: line-through; color: #999; font-weight:normal;">${originalForm}</span> âœ ${cleanText}`;
            }
        }

        // POS
        const posHtml = `<span>${item.pos}</span> <span style="font-size:0.7em; color:violet;">(ìˆ˜ì •ë¨)</span>`;

        // Grade
        const gradeNum = item.grade.replace(/[^0-9]/g, '');
        const badgeColorClass = gradeNum ? `grade-${gradeNum}` : 'grade-none';
        const badgeStyle = gradeNum ? '' : 'background-color:#94a3b8; color:white;';
        const gradeHtml = `<span class="grade-badge ${badgeColorClass}" style="font-size: 1rem; padding: 4px 12px; ${badgeStyle}">${item.grade}</span>`;

        // Desc
        const descText = item.desc || item.meaning;

        if (isInsideModal) {
            // [ëª¨ë‹¬/ì¼ê´„ ìˆ˜ì • ëª¨ë“œ] ëª¨ë‹¬ ë‚´ë¶€ì˜ í–‰ë§Œ ì—…ë°ì´íŠ¸
            currentEditingRow.querySelector('.modal-cell-form').innerHTML = formHtml;
            currentEditingRow.querySelector('.modal-cell-pos').innerHTML = posHtml;
            currentEditingRow.querySelector('.modal-cell-grade').innerHTML = gradeHtml;
            currentEditingRow.querySelector('.modal-cell-desc').innerText = descText;

            // Mark as edited
            const uiId = currentEditingRow.dataset.uiId;
            window.modalEditedRows.add(uiId);

            // Save applied data to row dataset for later confirmation
            currentEditingRow.dataset.finalForm = cleanText;
            currentEditingRow.dataset.finalPos = item.pos;
            currentEditingRow.dataset.finalGrade = item.grade;
            currentEditingRow.dataset.finalDesc = descText;
            currentEditingRow.dataset.finalTagCode = ""; // If available from item?

            // í™•ì¸ ì‹œ ë©”ì¸ í…Œì´ë¸”ë¡œ ì „ë‹¬í•  ID ì €ì¥
            if (item.uid) {
                const prefix = item.type === 'grammar' ? 'ë¬¸ë²•' : 'ë‹¨ì–´';
                currentEditingRow.dataset.finalId = `${prefix}#${item.uid}`;
            } else {
                currentEditingRow.dataset.finalId = "ìˆ˜ë™êµì •";
            }

            // [ëª¨ë‹¬/ì¼ê´„ ìˆ˜ì • ëª¨ë“œ] ëª¨ë‹¬ ë‚´ ID ì…€ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            const modalIdCell = currentEditingRow.querySelector('.modal-cell-id');
            if (modalIdCell) modalIdCell.innerText = currentEditingRow.dataset.finalId;

            closeEditModal();
            return; // STOP here. Do not update main table yet.
        }

        // [ë‹¨ì¼ ìˆ˜ì •] ë©”ì¸ í…Œì´ë¸” ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        const formCell = currentEditingRow.querySelector('.cell-form');
        formCell.innerHTML = formHtml;

        const posCell = currentEditingRow.querySelector('.cell-pos');
        posCell.innerHTML = posHtml;

        const gradeCell = currentEditingRow.querySelector('.cell-grade');
        gradeCell.innerHTML = gradeHtml;

        const descCell = currentEditingRow.querySelector('.cell-desc');
        descCell.innerText = descText;

        const idCell = currentEditingRow.querySelector('.cell-id');
        if (idCell) {
            // [MODIFIED] Real ID Display
            if (item.uid) {
                const prefix = item.type === 'grammar' ? 'ë¬¸ë²•' : 'ë‹¨ì–´';
                idCell.innerText = `${prefix}#${item.uid}`;
            } else {
                idCell.innerText = "ìˆ˜ë™êµì •";
            }
        }

        // Refresh Full UI
        if (window.refreshGradeChart) window.refreshGradeChart();
        if (window.updateVisualizedText) {
            const offset = currentEditingRow.dataset.offset;
            const uiId = currentEditingRow.dataset.uiId;
            window.updateVisualizedText(offset, item.grade, descText, cleanText, originalForm, uiId);
        }

        closeEditModal();
    }

    // ë‹¤ì¤‘ ì„ íƒ ë° ë³‘í•© ë¡œì§
    let selectedRows = [];

    function handleRowSelection() {
        // Find all selected checkboxes
        const checkboxes = document.querySelectorAll('.row-selector:checked');
        selectedRows = Array.from(checkboxes).map(cb => cb.closest('tr'));

        const btn = document.getElementById('floating-merge-btn');

        if (selectedRows.length >= 1) { // [MODIFIED] Allow 1+ selection
            btn.style.display = 'block';

            // [MODIFIED] Open Selection Edit Modal
            btn.innerHTML = `<span id="merge-count-badge" style="background: white; color: var(--color-primary); border-radius: 50%; padding: 2px 8px; margin-right: 8px; font-size: 0.9em;">${selectedRows.length}</span> ì„ íƒí•œ ë‹¨ì–´ ìˆ˜ì •í•˜ê¸°`;
            btn.onclick = openSelectionEditModal;
        } else {
            btn.style.display = 'none';
        }
    }

    function openSelectionEditModal() {
        if (selectedRows.length < 1) return;

        // Sort by row index
        selectedRows.sort((a, b) => a.rowIndex - b.rowIndex);

        const tbody = document.getElementById('selection-edit-tbody');
        tbody.innerHTML = '';

        // Track merged rows and edited status
        window.modalMergedRows = [];
        window.modalEditedRows = new Set();

        selectedRows.forEach((row, index) => {
            const tr = document.createElement('tr');

            // Clone cells
            const filename = row.querySelector('.cell-filename').innerText.trim();
            const form = row.querySelector('.cell-form').innerHTML;
            const pos = row.querySelector('.cell-pos').innerHTML;
            const grade = row.querySelector('.cell-grade').innerHTML;
            const id = row.querySelector('.cell-id').innerText;
            const desc = row.querySelector('.cell-desc').innerText;
            const originalUiId = row.dataset.uiId;
            const offset = row.dataset.offset;
            const originalForm = row.dataset.originalForm || row.querySelector('.cell-form').innerText;
            const tagCode = row.dataset.tagCode || "";

            tr.dataset.uiId = originalUiId;
            tr.dataset.offset = offset;
            tr.dataset.originalForm = originalForm;
            tr.dataset.tagCode = tagCode;
            tr.className = 'modal-row';

            tr.innerHTML = `
        <td style="padding:8px 10px; font-size:1rem; color:var(--color-primary);">${filename}</td>
        <td class="modal-cell-form" style="padding:8px 10px; font-weight:bold; font-size:1.1rem;">${form}</td>
        <td class="modal-cell-pos" style="padding:8px 10px;">${pos}</td>
        <td class="modal-cell-grade" style="padding:8px 10px;">${grade}</td>
        <td class="modal-cell-id" style="padding:8px 10px; font-size:0.9rem; color:#888;">${id}</td>
        <td class="modal-cell-desc" style="padding:8px 10px; color:var(--color-secondary); font-size:0.95rem;">${desc}</td>
        <td style="padding:8px 12px; text-align:center;">
            <button class="btn-edit-row" style="opacity:1; font-size:1.2rem;" onclick="triggerEditFromModal('${originalUiId}')">âœï¸</button>
        </td>
        `;
            tbody.appendChild(tr);

            // Add merge button row between adjacent items
            if (index < selectedRows.length - 1) {
                const nextRow = selectedRows[index + 1];

                // [FIXED] Check adjacency using rowIndex instead of offset
                // rowIndex includes header rows, so adjacent data rows differ by 1.
                if (nextRow.rowIndex - row.rowIndex === 1) {
                    const mergeRow = document.createElement('tr');
                    mergeRow.className = 'merge-button-row';
                    mergeRow.innerHTML = `
        <td colspan="7" style="padding: 2px; text-align: center; background: transparent; border: none;">
            <button class="merge-btn" onclick="mergeModalRows('${originalUiId}', '${nextRow.dataset.uiId}')"
                title="í•©ì¹˜ê¸°">
                <span style="font-size: 1.2em;">+</span>
            </button>
        </td>
        `;
                    tbody.appendChild(mergeRow);
                }
            }
        });

        document.getElementById('selection-edit-modal').showModal();
    }

    function closeSelectionEditModal() {
        document.getElementById('selection-edit-modal').close();
        // Clear tracking
        window.modalMergedRows = [];
        window.modalEditedRows = new Set();
    }

    function mergeModalRows(uiId1, uiId2) {
        const tbody = document.getElementById('selection-edit-tbody');
        const rows = Array.from(tbody.querySelectorAll('.modal-row'));

        const row1 = rows.find(r => r.dataset.uiId === uiId1);
        const row2 = rows.find(r => r.dataset.uiId === uiId2);

        if (!row1 || !row2) return;

        // Merge form
        const form1 = row1.querySelector('.modal-cell-form').innerText.trim();
        const form2 = row2.querySelector('.modal-cell-form').innerText.trim();
        const mergedForm = form1 + form2;

        row1.querySelector('.modal-cell-form').innerText = mergedForm;
        row1.querySelector('.modal-cell-pos').innerHTML = '<span style="color:violet; font-size:0.8em;">(\ubcd1\ud569\ub428)</span>';
        row1.dataset.merged = 'true';
        row1.dataset.mergedWith = uiId2;

        // Track this merge
        window.modalMergedRows.push({ parent: uiId1, child: uiId2, mergedForm });

        // Remove row2 and the merge button BETWEEN row1 and row2
        // Structure: row1 -> merge-btn -> row2
        const mergeBtnRow = row1.nextElementSibling;

        if (mergeBtnRow && mergeBtnRow.classList.contains('merge-button-row')) {
            mergeBtnRow.remove();
        }

        // Remove row2
        row2.remove();
    }

    function triggerEditFromModal(uiId) {
        // Find original row
        const originalRow = document.getElementById(uiId);

        // Find modal row to get CURRENT merged text
        const tbody = document.getElementById('selection-edit-tbody');
        // We use dataset.uiId. Note: merged rows retain the UI ID of the first/parent.
        const modalRows = Array.from(tbody.querySelectorAll('.modal-row'));
        const modalRow = modalRows.find(r => r.dataset.uiId === uiId);

        let currentText = null;
        if (modalRow) {
            currentText = modalRow.querySelector('.modal-cell-form').innerText.trim();
        }

        if (modalRow) {
            // [FIX] Pass the MODAL row as the editing context
            openEditModal(modalRow, currentText);
            // Mark as edited in modal
            window.modalEditedRows.add(uiId);
        } else if (originalRow) {
            // Fallback (shouldn't happen if triggered from modal)
            openEditModal(originalRow);
        }
    }

    function confirmSelectionEdits() {
        // Check if any merged rows are not edited
        // Merged parent rows will have dataset.merged === 'true'
        // But window.modalMergedRows tracks merge actions.
        // Actually, triggerEditFromModal adds the PARENT uiId to window.modalEditedRows.
        // So we just need to check if every parent in window.modalMergedRows has been edited.

        // Actually, more robust: Check the modal rows directly.
        const tbody = document.getElementById('selection-edit-tbody');
        const modalRows = Array.from(tbody.querySelectorAll('.modal-row'));

        let unEdited = false;
        modalRows.forEach(row => {
            if (row.dataset.merged === 'true') {
                // Check if this row (which is a merge parent) has been edited
                if (!window.modalEditedRows.has(row.dataset.uiId)) {
                    unEdited = true;
                }
            }
        });

        if (unEdited) {
            alert('ë³‘í•©ëœ ë‹¨ì–´ëŠ” ë°˜ë“œì‹œ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤. ì˜¤ë¥¸ìª½ "âœï¸" ë²„íŠ¼ì„ ëˆŒëŸ¬ ìˆ˜ì •í•˜ì„¸ìš”.');
            return;
        }

        // Apply changes to Main Table
        // 1. Delete consumed children
        window.modalMergedRows.forEach(merge => {
            const childRow = document.getElementById(merge.child);
            if (childRow) childRow.remove();
        });

        // 2. Update Survivors (Parents & Single Edits)
        modalRows.forEach(row => {
            const uiId = row.dataset.uiId;
            const mainRow = document.getElementById(uiId);
            if (mainRow) {
                // Retrieve saved data from applyEdit
                const newForm = row.dataset.finalForm;
                const newPos = row.dataset.finalPos;
                const newGrade = row.dataset.finalGrade;
                const newDesc = row.dataset.finalDesc;
                const newId = row.dataset.finalId; // [NEW] Retrieve final ID

                // If data exists (meaning it was edited), apply it
                if (newForm) {
                    // Form
                    const formCell = mainRow.querySelector('.cell-form');
                    // If merged, show clean new text. If single edit, show arrow.
                    if (row.dataset.merged === 'true') {
                        formCell.innerText = newForm;
                    } else {
                        const original = mainRow.dataset.originalForm || formCell.innerText;
                        if (original === newForm) formCell.innerText = newForm;
                        else formCell.innerHTML = `<span style="text-decoration: line-through; color: #999; font-weight:normal;">${original}</span> âœ ${newForm}`;
                    }

                    // POS
                    mainRow.querySelector('.cell-pos').innerHTML = `<span>${newPos}</span> <span style="font-size:0.7em; color:violet;">(ìˆ˜ì •ë¨)</span>`;

                    // Grade
                    const gradeNum = newGrade.replace(/[^0-9]/g, '');
                    const badgeColorClass = gradeNum ? `grade-${gradeNum}` : 'grade-none';
                    const badgeStyle = gradeNum ? '' : 'background-color:#94a3b8; color:white;';
                    mainRow.querySelector('.cell-grade').innerHTML = `<span class="grade-badge ${badgeColorClass}" style="font-size: 1rem; padding: 4px 12px; ${badgeStyle}">${newGrade}</span>`;

                    // Desc
                    mainRow.querySelector('.cell-desc').innerText = newDesc;

                    // ID
                    if (newId && mainRow.querySelector('.cell-id')) {
                        mainRow.querySelector('.cell-id').innerText = newId;
                    } else if (mainRow.querySelector('.cell-id')) {
                        mainRow.querySelector('.cell-id').innerText = "ìˆ˜ë™êµì •";
                    }

                    // Update Visualization (Complex part)
                    // If merged: We need to merge spans. 'consumed children' are gone.
                    // The parent span should be updated and children removed.
                    // We can use window.mergeVisualizedText([parent, children...])
                    if (row.dataset.merged === 'true') {
                        // Find all children consumed by this parent
                        // window.modalMergedRows contains pairs.
                        // Recursive search? Or simple filter.
                        // Since we support A+B, then if A is parent, B is child.
                        // But if A+B=AB, then AB+C=ABC?
                        // mergeModalRows updates dataset.mergedWith on the parent row? NO.
                        // mergeModalRows pushes to window.modalMergedRows.
                        // Let's gather all children associated with this parent.
                        // Simple approach: For this parent UIID, finds all `m.child` where `m.parent` matches?
                        // Wait, if A+B -> A(p), B(c). Then A(p)+C -> A(p), C(c).
                        // Yes, all children of A.
                        const childrenIds = window.modalMergedRows
                            .filter(m => m.parent === uiId)
                            .map(m => m.child);

                        if (childrenIds.length > 0 && window.mergeVisualizedText) {
                            // Combine parent + children
                            const allIds = [uiId, ...childrenIds];
                            window.mergeVisualizedText(allIds, newForm, newGrade, newDesc);
                        }
                    } else {
                        // Single edit
                        if (window.updateVisualizedText) {
                            window.updateVisualizedText(mainRow.dataset.offset, newGrade, newDesc, newForm, mainRow.dataset.originalForm || "", uiId);
                        }
                    }
                }
            }
        });

        // 3. Global Refresh
        if (window.refreshGradeChart) window.refreshGradeChart();

        // 4. Cleanup
        closeSelectionEditModal();
        document.querySelectorAll('.row-selector').forEach(cb => cb.checked = false);
        const btn = document.getElementById('floating-merge-btn');
        if (btn) btn.style.display = 'none';

        // Refresh selection button state
        handleRowSelection();
    }

    function closeMergeModal() {
        document.getElementById('merge-modal').close();
    }

    function applyMerge() {
        const modal = document.getElementById('merge-modal');
        const newText = document.getElementById('merge-input-text').value.trim();
        const newGrade = document.getElementById('merge-input-grade').value;
        const newDesc = "í•©ì³ì§„ ë‹¨ì–´"; // Simple desc

        if (!newText) {
            alert("ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        // 1. Update First Row
        const firstRow = selectedRows[0];
        const formCell = firstRow.querySelector('.cell-form');
        const gradeCell = firstRow.querySelector('.cell-grade');
        const posCell = firstRow.querySelector('.cell-pos');
        const descCell = firstRow.querySelector('.cell-desc');
        const idCell = firstRow.querySelector('.cell-id');

        // Update Content
        formCell.innerText = newText;

        // Grade Badge
        const gradeNum = newGrade.replace(/[^0-9]/g, '');
        const badgeColorClass = gradeNum ? `grade-${gradeNum}` : 'grade-none';
        const badgeStyle = gradeNum ? '' : 'background-color:#94a3b8; color:white;'; // Custom style for 'ë“±ê¸‰ ì—†ìŒ' if class missing

        gradeCell.innerHTML = `<span class="grade-badge ${badgeColorClass}" style="font-size: 1rem; padding: 4px 12px; ${badgeStyle}">${newGrade}</span>`;

        posCell.innerHTML = `<span style="font-size:0.8em; color:violet;">(ë³‘í•©ë¨)</span>`;
        descCell.innerText = newDesc;
        idCell.innerText = "ìˆ˜ë™ë³‘í•©";

        // 2. Remove Other Rows
        for (let i = 1; i < selectedRows.length; i++) {
            selectedRows[i].remove();
        }

        // 3. Call Visualization Update
        // Provide list of UI IDs to merge
        if (window.mergeVisualizedText) {
            const uiIds = selectedRows.map(row => row.dataset.uiId);
            window.mergeVisualizedText(uiIds, newText, newGrade, newDesc);
        }

        // 4. Update Charts
        if (window.refreshGradeChart) {
            window.refreshGradeChart();
        }

        // 5. Cleanup
        modal.close();

        // Reset Selection
        document.querySelectorAll('.row-selector').forEach(cb => cb.checked = false);
        handleRowSelection(); // Hide button
    }
</script>