<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem;">
    <h4 style="margin: 0; font-weight: 700; color: #ccc;">ğŸ“Š ìƒì„¸ ë¶„ì„ ê²°ê³¼</h4>
    <button type="button" class="outline contrast" onclick="copyTableText()"
        style="padding: 6px 16px; font-size: 0.85rem; margin-bottom: 0;">
        ğŸ“‹ í…ìŠ¤íŠ¸ë¡œ ë³µì‚¬
    </button>
</div>

<div class="table-container">
    <table id="analysis-table" class="striped">
        <thead>
            <tr>
                <th scope="col" style="width: 15%;">í‘œì œì–´</th>
                <th scope="col" style="width: 20%;">í’ˆì‚¬</th>
                <th scope="col" style="width: 10%;">ë“±ê¸‰</th>
                <th scope="col" style="width: 15%;">ë²ˆí˜¸</th>
                <th scope="col">ê¸¸ì¡ì´ë§</th>
                <th scope="col" style="width: 60px; text-align: center;">ìˆ˜ì •</th>
            </tr>
        </thead>
        <tbody>
            {% for row in analysis_result %}
            <tr data-original-form="{{ row.form }}" data-tag-code="{{ row.tag_code }}"
                data-offset="{{ row.offset_start }}" data-ui-id="{{ row._ui_id }}">
                <td class="cell-form" style="font-weight: bold; color: var(--color-text);">{{ row.form }}</td>
                <td class="cell-pos">
                    <span data-tooltip="{{ row.tag_code }}" style="border-bottom: 1px dotted #888; cursor: help;">
                        {{ row.tag_name }}
                    </span>
                </td>
                <td class="cell-grade">
                    {% if 'ê¸‰' in row.level %}
                    <span class="grade-badge grade-{{ row.level[0] }}" style="font-size: 1rem; padding: 4px 12px;">
                        {{ row.level }}
                    </span>
                    {% else %}
                    <span style="color: var(--color-text-muted);">-</span>
                    {% endif %}
                </td>
                <td class="cell-id" style="font-family: monospace; font-size: 0.95rem; color: var(--color-text-muted);">
                    {{ row.id }}
                </td>
                <td class="cell-desc" style="color: var(--color-secondary);">
                    {{ row.desc }}
                </td>
                <td style="text-align: center;">
                    <button class="btn-edit-row" onclick="openEditModal(this)" title="ë“±ê¸‰ ìˆ˜ë™ ìˆ˜ì •">
                        âœï¸
                    </button>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- ìˆ˜ë™ ìˆ˜ì • ëª¨ë‹¬ -->
<dialog id="word-edit-modal">
    <article style="min-width: 500px;">
        <header>
            <button aria-label="Close" rel="prev" onclick="closeEditModal()"></button>
            <strong>ğŸ› ï¸ ë“±ê¸‰ ìˆ˜ë™ ìˆ˜ì •</strong>
        </header>
        <p style="margin-bottom: 1rem; font-size: 0.9rem; color: var(--color-text-muted);">
            ê²€ìƒ‰ì„ í†µí•´ í•´ë‹¹ í–‰ì˜ ì •ë³´ë¥¼ êµì²´í•©ë‹ˆë‹¤. <br>
            (ê¸°ì¡´ í‘œì œì–´ëŠ” ìœ ì§€ë˜ê±°ë‚˜ 'ê¸°ì¡´ -> ìƒˆë‹¨ì–´'ë¡œ í‘œì‹œë©ë‹ˆë‹¤.)
        </p>

        <!-- [MODIFIED] Unified Search Bar Style -->
        <div class="grid" style="grid-template-columns: 1fr 3fr; gap: 10px; margin-bottom: 1rem;">
            <select id="edit-search-type" style="margin-bottom:0;">
                <option value="word" selected>ë‹¨ì–´</option>
                <option value="grammar">ë¬¸ë²•</option>
            </select>
            <input type="search" id="edit-search-input" placeholder="ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ì¡ë‹¤, ì§„í™)" style="margin-bottom:0;"
                autocomplete="off">
        </div>

        <div id="edit-search-results"
            style="max-height: 300px; overflow-y: auto; border: 1px solid var(--muted-border-color); border-radius: 8px; display: none;">
            <!-- ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ -->
        </div>
    </article>
</dialog>

<style>
    .table-container {
        overflow-x: auto;
        border: 1px solid var(--muted-border-color);
        border-radius: 8px;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.05rem;
    }

    th {
        background-color: rgba(255, 255, 255, 0.05);
        text-align: left;
        font-weight: 600;
        padding: 14px;
    }

    td {
        padding: 14px;
        border-bottom: 1px solid var(--muted-border-color);
        vertical-align: middle;
    }

    tr:last-child td {
        border-bottom: none;
    }

    /* ì˜¤ë¦¬ì§€ë„ ë“±ê¸‰ ìƒ‰ìƒ ë³µì› (í…Œì´ë¸” ë‚´ë¶€ìš©) */
    .grade-badge {
        display: inline-block;
        border-radius: 12px;
        color: #fff;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .grade-1 {
        background-color: #10b981;
    }

    .grade-2 {
        background-color: #3b82f6;
    }

    .grade-3 {
        background-color: #8b5cf6;
    }

    .grade-4 {
        background-color: #f59e0b;
    }

    .grade-5 {
        background-color: #ef4444;
    }

    .grade-6 {
        background-color: #64748b;
    }


    /* ìˆ˜ì • ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .btn-edit-row {
        background: transparent;
        border: none;
        cursor: pointer;
        font-size: 1.1rem;
        opacity: 0.3;
        transition: opacity 0.2s;
        padding: 4px;
    }

    .btn-edit-row:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    /* [MODIFIED] ê²€ìƒ‰ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì•„ì´í…œ ìŠ¤íƒ€ì¼ (Feature 2 í‘œì¤€ê³¼ ë™ì¼í•˜ê²Œ ìˆ˜ì •) */
    .edit-result-item {
        padding: 12px;
        border-bottom: 1px solid #333;
        cursor: pointer;
        transition: background 0.1s;
        text-align: left;
        /* ê¸°ì¡´ flex/background ì œê±°í•˜ì—¬ Feature 2 ìŠ¤íƒ€ì¼ë¡œ í†µì¼ */
    }

    .edit-result-item:hover {
        background-color: #3e3e3e;
    }

    .edit-result-item:last-child {
        border-bottom: none;
    }
</style>

<script>
    let currentEditingRow = null;
    let localDebounceTimer; // [NEW] ë””ë°”ìš´ì‹± íƒ€ì´ë¨¸

    function copyTableText() {
        const table = document.getElementById('analysis-table');
        if (!table) return;
        let textToCopy = "";

        // í—¤ë”
        const headers = Array.from(table.querySelectorAll('thead th'))
            .slice(0, -1)
            .map(th => th.innerText);
        textToCopy += headers.join('\t') + '\n';

        // ë³¸ë¬¸
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const cells = Array.from(row.querySelectorAll('td'))
                .slice(0, -1)
                .map(td => td.innerText.replace(/[\r\n]+/g, " ").trim());
            textToCopy += cells.join('\t') + '\n';
        });

        navigator.clipboard.writeText(textToCopy).then(() => {
            alert('í…ìŠ¤íŠ¸ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! ì—‘ì…€ì— ë¶™ì—¬ë„£ê¸° ì¢‹ìŠµë‹ˆë‹¤.');
        });
    }

    function openEditModal(btn) {
        currentEditingRow = btn.closest('tr');
        const modal = document.getElementById('word-edit-modal');
        modal.showModal();

        // [NEW] Auto-Search Implementation
        const originalForm = currentEditingRow.dataset.originalForm || currentEditingRow.querySelector('.cell-form').innerText;
        const tagCode = currentEditingRow.dataset.tagCode || ""; // Get tag code

        const searchInput = document.getElementById('edit-search-input');
        const typeSelect = document.getElementById('edit-search-type');

        // Auto-detect type
        if (tagCode.startsWith('J') || tagCode.startsWith('E')) {
            typeSelect.value = 'grammar';
        } else {
            typeSelect.value = 'word';
        }

        searchInput.value = originalForm; // Pre-fill
        searchInput.focus();

        // Trigger search immediately with correct type
        searchForEdit(originalForm, typeSelect.value);
    }

    function closeEditModal() {
        const modal = document.getElementById('word-edit-modal');
        modal.close();
        currentEditingRow = null;
    }

    // [MODIFIED] ë””ë°”ìš´ì‹± ì ìš©ëœ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const editSearchInput = document.getElementById('edit-search-input');
    if (editSearchInput) {
        // ì—”í„°í‚¤ ë°©ì§€ (í¼ ì „ì†¡ ë°©ì§€)
        editSearchInput.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') e.preventDefault();
        });

        editSearchInput.addEventListener('input', function () {
            const query = this.value.trim();
            const type = document.getElementById('edit-search-type').value;

            if (query.length < 1) {
                clearTimeout(localDebounceTimer);
                document.getElementById('edit-search-results').style.display = 'none';
                return;
            }

            // ë””ë°”ìš´ì‹± (300ms)
            clearTimeout(localDebounceTimer);
            localDebounceTimer = setTimeout(() => {
                searchForEdit(query, type);
            }, 300);
        });
    }

    async function searchForEdit(query, type) {
        const list = document.getElementById('edit-search-results');
        // list.innerHTML = '<div style="padding:10px; text-align:center;">ê²€ìƒ‰ ì¤‘...</div>'; 
        // -> ê²€ìƒ‰ ì¤‘ í‘œì‹œëŠ” íƒ€ì´í•‘ ì¤‘ì— ê±°ìŠ¬ë¦´ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ìƒëµí•˜ê±°ë‚˜ ìµœì†Œí™”

        try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}&type=${type}`);
            const data = await res.json();

            list.innerHTML = '';
            if (data.length === 0) {
                list.style.display = 'block';
                list.innerHTML = '<div style="padding:10px; text-align:center; color:#888;">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
                return;
            }

            list.style.display = 'block';
            data.forEach(item => {
                const div = document.createElement('div');
                div.className = 'edit-result-item'; // CSS í´ë˜ìŠ¤ ì ìš©

                // ë Œë”ë§ ë¡œì§ (search.jsì™€ ë™ì¼í•˜ê²Œ êµ¬ì„±)

                // 1. íŒíŠ¸
                const hintText = (item.desc && item.desc !== 'nan')
                    ? `<span style="color:#aaa; font-size:0.85em; margin-left:6px;">${item.desc}</span>`
                    : '';

                // 2. í’ˆì‚¬
                const posText = item.pos
                    ? `<span style="color:#a855f7; font-weight:600; font-size:0.85em; margin-left:4px;">[${item.pos}]</span>`
                    : '';

                // 3. ê´€ë ¨í˜•
                let relatedText = '';
                if (item.related) {
                    relatedText = `<span style="color:#ff9f43; font-size:0.8em; margin-left:6px;">(ê´€ë ¨í˜•: ${item.related})</span>`;
                }

                // 4. ë“±ê¸‰ ë°°ì§€ (Solid Color)
                const gradeNum = item.grade.replace(/[^0-9]/g, '');
                const colorMap = {
                    '1': '#10b981', '2': '#3b82f6', '3': '#8b5cf6',
                    '4': '#f59e0b', '5': '#ef4444', '6': '#64748b'
                };
                const bgColor = colorMap[gradeNum] || '#94a3b8';

                div.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            <strong>${item.text}</strong>
                            ${posText}
                            ${relatedText}
                            ${hintText}
                        </div>
                        <span style="font-size:0.75em; color:#fff; background:${bgColor}; padding: 2px 6px; border-radius:4px; white-space: nowrap; margin-left: 10px;">
                            ${item.grade}
                        </span>
                    </div>
                `;

                div.onclick = () => applyEdit(item);
                list.appendChild(div);
            });

        } catch (e) {
            list.innerHTML = `<div style="padding:10px; color:red;">ì—ëŸ¬: ${e}</div>`;
        }
    }

    function applyEdit(item) {
        if (!currentEditingRow) return;

        // [NEW] Text Cleaning Logic
        // 1. Remove trailing numbers (e.g., "ì‹ ë¬¸02" -> "ì‹ ë¬¸")
        // 2. Remove leading/trailing hyphens/tildes (e.g., "-ì„ê¹Œ" -> "ì„ê¹Œ")
        let cleanText = item.text || item.word || "";
        cleanText = cleanText.replace(/[0-9]+$/, '');
        cleanText = cleanText.replace(/^[-~]+|[-~]+$/g, '');

        // 1. í‘œì œì–´ (ì›ë˜ -> ìƒˆê±°)
        const originalForm = currentEditingRow.dataset.originalForm || currentEditingRow.querySelector('.cell-form').innerText;
        // ë§Œì•½ ì´ë¯¸ ìˆ˜ì •ëœ ìƒíƒœë¼ë©´ originalForm ìœ ì§€
        if (!currentEditingRow.dataset.originalForm) {
            currentEditingRow.dataset.originalForm = originalForm;
        }

        const formCell = currentEditingRow.querySelector('.cell-form');
        // ê°™ì€ ë‹¨ì–´ë©´ ê·¸ëŒ€ë¡œ, ë‹¤ë¥´ë©´ í™”ì‚´í‘œ í‘œì‹œ
        if (originalForm === cleanText) {
            formCell.innerText = cleanText;
        } else {
            formCell.innerHTML = `<span style="text-decoration: line-through; color: #999; font-weight:normal;">${originalForm}</span> âœ ${cleanText}`;
        }

        // 2. í’ˆì‚¬
        const posCell = currentEditingRow.querySelector('.cell-pos');
        posCell.innerHTML = `<span>${item.pos}</span> <span style="font-size:0.7em; color:violet;">(ìˆ˜ì •ë¨)</span>`;

        // 3. ë“±ê¸‰ (Keep original solid badges in the table, user only asked for SEARCH results to be changed)
        const gradeCell = currentEditingRow.querySelector('.cell-grade');
        const gradeNum = item.grade.replace('ê¸‰', '');
        gradeCell.innerHTML = `<span class="grade-badge grade-${gradeNum}" style="font-size: 1rem; padding: 4px 12px;">${item.grade}</span>`;

        // 4. ë²ˆí˜¸ (ID)
        const idCell = currentEditingRow.querySelector('.cell-id');
        idCell.innerText = "ìˆ˜ë™êµì •";

        // 5. ê¸¸ì¡ì´ë§
        const descCell = currentEditingRow.querySelector('.cell-desc');
        descCell.innerText = item.desc || item.meaning;

        // [NEW] Refresh Full UI (Pie Chart + Overall Grade + Visualized Text)
        if (window.refreshGradeChart) {
            window.refreshGradeChart(); // Internally calls updateOverallGrade
        }

        if (window.updateVisualizedText) {
            const offset = currentEditingRow.dataset.offset;
            const uiId = currentEditingRow.dataset.uiId;
            // Use cleaned text for visualization as well
            const newText = cleanText;

            // Robustly get original form (try dataset first, then cell text)
            let originalForm = currentEditingRow.dataset.originalForm;
            if (!originalForm) {
                const formCell = currentEditingRow.querySelector('.cell-form');
                if (formCell) originalForm = formCell.innerText.trim();
            }

            window.updateVisualizedText(offset, item.grade, item.desc || item.meaning, newText, originalForm || "", uiId);
        }

        // [Moved] Close modal LAST to ensure currentEditingRow remains valid during updates
        closeEditModal();
    }
</script>